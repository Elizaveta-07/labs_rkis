<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>
        function square(number) {
    return number * number;
}
return number * number;
function myFunc(theObject) {
    theObject.make = "Toyota";
    }
    var mycar = { make: "Honda", model: "Accord", year: 1998 };
    var x, y;
    x = mycar.make; // x получает значение "Honda"
myFunc(mycar);
    y = mycar.make; // y получает значение "Toyota"
// (свойство было изменено функцией)
var square = function (number) {
    return number * number;
    };
    var x = square(4); // x получает значение 16
    var factorial = function fac(n) {
    return n < 2 ? 1 : n * fac(n - 1);
};
    console.log(factorial(3));
    function map(f, a) {
    var result = [], // Создаём новый массив
    i;
    for (i = 0; i != a.length; i++) result[i] = f(a[i]);
    return result;
}
    function map(f, a) {
    var result = []; // Создаём новый массив
    var i; // Объявляем переменную
    for (i = 0; i != a.length; i++) result[i] = f(a[i]);
    return result;
}
    var f = function (x) {
    return x * x * x;
};
    var numbers = [0, 1, 2, 5, 10];
    var cube = map(f, numbers);
    console.log(cube);
   
    var myFunc;
    if (num === 0) {
    myFunc = function (theObject) {
    theObject.make = "Toyota";
 };
}



square(5);
console.log(square(5));
/* ... */
function square(n) {
return n * n;
}

console.log(square); // square поднят со значением undefined.
console.log(square(5)); // TypeError: square is not a function
var square = function (n) {
return n * n;
};
function factorial(n) {
    if (n === 0 || n === 1) return 1;
    else return n * factorial(n - 1);
}
var a, b, c, d, e;
a = factorial(1); // a получает значение 1
b = factorial(2); // b получает значение 2
c = factorial(3); // c получает значение 6
d = factorial(4); // d получает значение 24
e = factorial(5); // e получает значение 120

// Следующие переменные объявленны в глобальном scope
var num1 = 20,
num2 = 3,
name = "Chamahk";
// Эта функция объявленна в глобальном scope
function multiply() {
return num1 * num2;
}
multiply(); // вернёт 60
// Пример вложенной функции
function getScore() {
var num1 = 2,
num2 = 3;
function add() {
return name + " scored " + (num1 + num2);
}
return add();
}
getScore(); // вернёт "Chamahk scored 5"

var x = 0;
while (x < 10) {
// "x < 10" — это условие для цикла
// что-то делаем
x++;
}

function loop(x) {
    if (x >= 10) {
    // "x >= 10" — это условие для конца выполнения (тоже самое, что "!(x < 10)")
    return;
    }
    // делать что-то
    loop(x + 1); // рекурсионный вызов
    }
    loop(0);

    function walkTree(node) {
        if (node == null) return;
        // что-то делаем с элементами
        for (var i = 0; i < node.childNodes.length; i++) {
        walkTree(node.childNodes[i]);
    }
}

function foo(i) {
    if (i < 0) return;
    console.log("begin: " + i);
    foo(i - 1);
    console.log("end: " + i);
    }
    foo(3);

function addSquares(a, b) {
    function square(x) {
    return x * x;
}
    return square(a) + square(b);
}
    a = addSquares(2, 3); // возвращает 13
    b = addSquares(3, 4); // возвращает 25
    c = addSquares(4, 5); // возвращает 41

function outside(x) {
function inside(y) {
    return x + y;
}
    return inside;
}
    fn_inside = outside(3); // Думайте об этом как: дайте мне функцию,
    // которая добавляет 3 к любому введенному значению

result = fn_inside(5); // возвращает 8
result1 = outside(3)(5); // возвращает 8

function A(x) {
    function B(y) {
    function C(z) {
    console.log(x + y + z);
}
    C(3);
}
    B(2);
}
    A(1); // в консоле выводится 6 (1 + 2 + 3)

    function outside() {
    var x = 5;
    function inside(x) {
    return x * 2;
}
    return inside;
}
    outside()(10); // возвращает 20 вместо 10

var pet = function (name) {
        // Внешняя функция объявила переменную "name"
        var getName = function () {
        return name; // Вложенная функция имеет доступ к "name" внешней функции
        };
        return getName; // Возвращаем вложенную функцию, тем самым сохраняя доступ
        // к ней для другого scope
        };
        myPet = pet("Vivie");
        myPet(); // Возвращается "Vivie",
        // т.к. даже после выполнения внешней функции
        // name сохранился для вложенной функции

var createPet = function (name) {
var sex;
    return {
    setName: function (newName) {
    name = newName;
},
    getName: function () {
    return name;
},
    getSex: function () {
    return sex;
},
    setSex: function (newSex) {
    if (
    typeof newSex === "string" &&
    (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
) {
    sex = newSex;
}
    },
};
    };

var pet = createPet("Vivie");
    pet.getName(); // Vivie
    pet.setName("Oliver");
    pet.setSex("male");
    pet.getSex(); // male
    pet.getName(); // Oliver

var getCode = (function () {
var apiCode = "0]Eal(eh&2"; // Мы не хотим, чтобы данный код мог быть изменен кем-то извне...
    return function () {
    return apiCode;
};
    })();
    getCode(); // Возвращает apiCode

    var createPet = function (name) {
// Внешняя функция определяет переменную с именем "name".
    return {
    setName: function (name) {
    // Внутренняя функция также определяет переменную с именем "name".
    name = name; // Как мы можем получить доступ к "name", определённой во внешней функции?
},
    };
};



arguments[i];
function myConcat(separator) {
var result = "";
var i;
    // iterate through arguments
    for (i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
}
    return result;
}

// возвращает "red, orange, blue, "
myConcat(", ", "red", "orange", "blue");
// возвращает "elephant; giraffe; lion; cheetah; "
myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
// возвращает "sage. basil. oregano. pepper. parsley. "
myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley");


function multiply(a, b) {
    b = typeof b !== "undefined" ? b : 1;
    return a * b;
}
    multiply(5); // 5


function multiply(a, b = 1) {
    return a * b;
}
    multiply(5); // 5


function multiply(multiplier, ...theArgs) {
    return theArgs.map((x) => multiplier * x);
}
    var arr = multiply(2, 1, 2, 3);
    console.log(arr); // [2, 4, 6]



var a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];
var a2 = a.map(function (s) {
    return s.length;
});
    console.log(a2); // выводит [8, 6, 7, 9]
var a3 = a.map((s) => s.length);
    console.log(a3); // выводит [8, 6, 7, 9]



function Person() {
        // Конструктор Person() определяет `this` как самого себя.
    this.age = 0;
    setInterval(function growUp() {
        // Без strict mode функция growUp() определяет `this`
        // как global object, который отличается от `this`
        // определённого конструктором Person().
    this.age++;
}, 1000);
    }
var p = new Person();


function Person() {
    var self = this; // Некоторые выбирают `that` вместо `self`.
    // Выберите что-то одно и будьте последовательны.
    self.age = 0;
    setInterval(function growUp() {
    // Колбэк ссылается на переменную `self`,
    // значением которой является ожидаемый объект.
    self.age++;
    }, 1000);
    }

function Person() {
    this.age = 0;
    setInterval(() => {
        this.age++; // |this| должным образом ссылается на объект Person
    }, 1000);
}

var p = new Person();
    </script>
    
</body>
</html>